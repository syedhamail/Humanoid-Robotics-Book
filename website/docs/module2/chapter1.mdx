---
title: Introduction to Physics Simulation
description: Fundamentals of physics simulation for humanoid robotics in Gazebo and other simulators
---

import DocCardList from '@theme/DocCardList';

## Learning Objectives

After completing this chapter, you will be able to:
- Understand the principles of physics simulation in robotics
- Explain the role of simulation in humanoid robot development
- Identify key physics engines and their applications
- Describe collision detection and response mechanisms
- Analyze the trade-offs between simulation accuracy and performance

## Prerequisites

Before starting this chapter, you should:
- Have completed Module 1 on ROS 2 fundamentals and robot control
- Understand basic physics concepts (forces, torques, dynamics)
- Be familiar with 3D coordinate systems and transformations
- Have experience with robot kinematics and dynamics

## Introduction

Physics simulation is a cornerstone of modern robotics development, particularly for complex systems like humanoid robots. It provides a safe, cost-effective, and controllable environment for testing algorithms, validating designs, and training AI systems before deployment on physical robots.

For humanoid robotics, physics simulation is especially critical because:
- Humanoid robots have complex kinematic structures with many degrees of freedom
- Dynamic balance and locomotion require precise physics modeling
- Safety considerations make extensive real-world testing impractical
- Training data for AI systems can be efficiently generated in simulation

Modern physics simulators like Gazebo, NVIDIA Isaac Sim, and Unity provide sophisticated engines that model:
- Rigid body dynamics
- Contact mechanics
- Friction and damping
- Fluid dynamics (for advanced applications)
- Sensor simulation

## Core Concepts

### Physics Engine Fundamentals

A physics engine solves Newtonian mechanics equations to simulate the motion of objects over time. Key components include:

- **Integration Methods**: Techniques to solve differential equations (Euler, Runge-Kutta, Verlet)
- **Collision Detection**: Algorithms to identify when objects intersect
- **Constraint Solvers**: Systems to handle joint constraints and contacts
- **Broad Phase/ Narrow Phase**: Hierarchical approaches to optimize collision detection

### Simulation Fidelity vs Performance

Simulation fidelity refers to how closely the simulation matches reality. Higher fidelity typically requires more computational resources. Trade-offs include:

- **High Fidelity**: Accurate material properties, complex contact models, detailed meshes
- **Medium Fidelity**: Simplified contact models, reduced mesh complexity, approximate dynamics
- **Low Fidelity**: Simple geometric shapes, basic physics, fastest performance

### Real-Time vs Non-Real-Time Simulation

- **Real-Time Simulation**: Clock time equals simulation time (1x speed)
- **Faster Than Real-Time**: Simulation runs faster than clock time (2x, 5x, etc.)
- **Non-Real-Time**: Simulation speed unconstrained by wall-clock time

### Simulation Artifacts

Common simulation artifacts that differ from reality:
- Discrete time stepping effects
- Numerical integration errors
- Simplified contact models
- Mesh resolution limitations

## Code Examples

### Basic Physics Simulation Setup

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import SpawnEntity, DeleteEntity
from gazebo_msgs.msg import ModelState
from geometry_msgs.msg import Pose, Point, Quaternion
from std_msgs.msg import Header
import xml.etree.ElementTree as ET
import time


class PhysicsSimManager(Node):
    """
    Manager for physics simulation tasks in Gazebo.
    """

    def __init__(self):
        super().__init__('physics_sim_manager')

        # Services for entity management
        self.spawn_entity_cli = self.create_client(SpawnEntity, '/spawn_entity')
        self.delete_entity_cli = self.create_client(DeleteEntity, '/delete_entity')

        # Publisher for model state updates
        self.model_state_pub = self.create_publisher(ModelState, '/model_state', 10)

        # Wait for services
        while not self.spawn_entity_cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Spawn service not available, waiting...')

        while not self.delete_entity_cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Delete service not available, waiting...')

        self.get_logger().info('Physics Simulation Manager initialized')

    def spawn_model(self, model_name, model_xml, initial_pose):
        """Spawn a model in the simulation."""
        req = SpawnEntity.Request()
        req.name = model_name
        req.xml = model_xml
        req.initial_pose = initial_pose

        future = self.spawn_entity_cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Successfully spawned {model_name}')
                return True
            else:
                self.get_logger().error(f'Failed to spawn {model_name}: {response.status_message}')
                return False
        else:
            self.get_logger().error(f'Failed to call spawn service: {future.exception()}')
            return False

    def configure_physics_properties(self):
        """Configure physics engine properties for humanoid simulation."""
        # In practice, this would call Gazebo services to set physics parameters
        # like gravity, solver type, iterations, etc.

        # Example physics parameters for humanoid simulation
        physics_config = {
            'gravity_x': 0.0,
            'gravity_y': 0.0,
            'gravity_z': -9.81,  # Earth's gravity
            'solver_type': 'ode',  # Open Dynamics Engine
            'max_step_size': 0.001,  # 1ms time step for accuracy
            'real_time_factor': 1.0,  # Real-time simulation
            'max_contacts': 20,  # Maximum contacts per collision
            'cfm': 0.0,  # Constraint Force Mixing parameter
            'erp': 0.2   # Error Reduction Parameter
        }

        self.get_logger().info('Physics properties configured for humanoid simulation')
        return physics_config


def create_humanoid_robot_xml():
    """Create a basic humanoid robot model definition."""
    robot_xml = """
    <?xml version="1.0" ?>
    <robot name="simple_humanoid">
      <link name="base_link">
        <inertial>
          <mass value="10.0"/>
          <origin xyz="0 0 0.5"/>
          <inertia ixx="1.0" ixy="0.0" ixz="0.0" iyy="1.0" iyz="0.0" izz="1.0"/>
        </inertial>
        <visual>
          <origin xyz="0 0 0.5"/>
          <geometry>
            <box size="0.5 0.5 1.0"/>
          </geometry>
          <material name="blue">
            <color rgba="0 0 1 0.8"/>
          </material>
        </visual>
        <collision>
          <origin xyz="0 0 0.5"/>
          <geometry>
            <box size="0.5 0.5 1.0"/>
          </geometry>
        </collision>
      </link>

      <link name="right_leg">
        <inertial>
          <mass value="5.0"/>
          <origin xyz="0 0 -0.25"/>
          <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.05"/>
        </inertial>
        <visual>
          <origin xyz="0 0 -0.25"/>
          <geometry>
            <cylinder radius="0.08" length="0.5"/>
          </geometry>
          <material name="white">
            <color rgba="1 1 1 0.8"/>
          </material>
        </visual>
        <collision>
          <origin xyz="0 0 -0.25"/>
          <geometry>
            <cylinder radius="0.08" length="0.5"/>
          </geometry>
        </collision>
      </link>

      <joint name="base_to_right_leg" type="fixed">
        <parent link="base_link"/>
        <child link="right_leg"/>
        <origin xyz="0 -0.2 -0.5"/>
      </joint>

      <!-- Additional links and joints would define a complete humanoid -->
    </robot>
    """
    return robot_xml


def main(args=None):
    rclpy.init(args=args)

    sim_manager = PhysicsSimManager()

    # Create and spawn a simple humanoid
    humanoid_xml = create_humanoid_robot_xml()

    initial_pose = Pose()
    initial_pose.position.x = 0.0
    initial_pose.position.y = 0.0
    initial_pose.position.z = 1.0  # Start slightly above ground
    initial_pose.orientation.w = 1.0  # No rotation

    success = sim_manager.spawn_model('simple_humanoid', humanoid_xml, initial_pose)

    if success:
        # Configure physics properties
        physics_props = sim_manager.configure_physics_properties()

        try:
            rclpy.spin(sim_manager)
        except KeyboardInterrupt:
            pass
    else:
        sim_manager.get_logger().error('Failed to spawn humanoid model')

    sim_manager.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Physics Parameter Configuration

```python
#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from gazebo_msgs.srv import SetPhysicsProperties, GetPhysicsProperties
from gazebo_msgs.msg import ODEPhysics
from geometry_msgs.msg import Vector3


class PhysicsConfigurator(Node):
    """
    Configure physics engine properties for optimal humanoid simulation.
    """

    def __init__(self):
        super().__init__('physics_configurator')

        # Services for physics configuration
        self.set_physics_cli = self.create_client(
            SetPhysicsProperties,
            '/set_physics_properties'
        )
        self.get_physics_cli = self.create_client(
            GetPhysicsProperties,
            '/get_physics_properties'
        )

        # Wait for services
        while not self.set_physics_cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Set physics service not available, waiting...')

        while not self.get_physics_cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Get physics service not available, waiting...')

        self.get_logger().info('Physics Configurator initialized')

    def get_current_physics_properties(self):
        """Get current physics engine properties."""
        req = GetPhysicsProperties.Request()
        future = self.get_physics_cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            self.get_logger().info('Retrieved current physics properties')
            return response
        else:
            self.get_logger().error(f'Failed to get physics properties: {future.exception()}')
            return None

    def set_optimized_physics_properties(self):
        """Set physics properties optimized for humanoid simulation."""
        req = SetPhysicsProperties.Request()

        # Gravity vector (Earth-like)
        req.gravity = Vector3(x=0.0, y=0.0, z=-9.81)

        # Time step properties for stable humanoid simulation
        req.time_step = 0.001  # 1ms for high fidelity
        req.max_step_size = 0.001
        req.real_time_factor = 1.0  # Real-time simulation

        # ODE physics engine parameters
        req.ode_config = ODEPhysics()
        req.ode_config.auto_disable_bodies = False
        req.ode_config.sor_pgs_precon_iters = 0
        req.ode_config.sor_pgs_iters = 50  # Higher for stability
        req.ode_config.sor_pgs_w = 1.3    # Over-relaxation parameter
        req.ode_config.contact_surface_layer = 0.001
        req.ode_config.contact_max_correcting_vel = 100.0
        req.ode_config.cfm = 0.0          # Constraint Force Mixing
        req.ode_config.erp = 0.2          # Error Reduction Parameter
        req.ode_config.max_contacts = 20

        future = self.set_physics_cli.call_async(req)
        rclpy.spin_until_future_complete(self, future)

        if future.result() is not None:
            response = future.result()
            if response.success:
                self.get_logger().info('Successfully set optimized physics properties')
                return True
            else:
                self.get_logger().error(f'Failed to set physics properties: {response.status_message}')
                return False
        else:
            self.get_logger().error(f'Failed to call set physics service: {future.exception()}')
            return False


def main(args=None):
    rclpy.init(args=args)

    config_node = PhysicsConfigurator()

    # Display current properties
    current_props = config_node.get_current_physics_properties()
    if current_props:
        config_node.get_logger().info(
            f'Current time step: {current_props.time_step}, '
            f'gravity: ({current_props.gravity.x}, {current_props.gravity.y}, {current_props.gravity.z})'
        )

    # Set optimized properties for humanoid simulation
    success = config_node.set_optimized_physics_properties()

    if success:
        config_node.get_logger().info('Physics engine configured for humanoid simulation')
    else:
        config_node.get_logger().error('Failed to configure physics engine')

    config_node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Diagrams and Visuals

![Physics Simulation Pipeline](/img/diagrams/physics-simulation-pipeline.png)

*Figure 1: The physics simulation pipeline showing the flow from robot models through physics calculations to simulated sensor data.*

## Hands-On Lab

### Exercise 1: Physics Property Tuning
Experiment with different physics properties to observe their effects:

1. Create a simple model with a box falling under gravity
2. Adjust the time step and observe simulation accuracy vs performance
3. Change ERP and CFM values to see their effect on contact stability
4. Document the trade-offs between different parameter settings

### Exercise 2: Collision Geometry Analysis
Compare different collision geometries for humanoid simulation:

1. Create the same robot model with different collision approximations:
   - Primitive shapes (boxes, cylinders, spheres)
   - Convex hulls
   - Detailed meshes
2. Measure simulation performance and stability for each
3. Compare the realism of interactions with the environment
4. Determine the optimal balance for humanoid applications

## Troubleshooting

Common physics simulation issues and solutions:

- **Issue: Robot falls through the ground**: Check collision geometries and ensure the ground plane has proper static properties.
- **Issue: Unstable joint movements**: Increase solver iterations, reduce time step, or adjust ERP/CFM values.
- **Issue: Excessive simulation time**: Use simpler collision geometries, increase time step, or reduce solver iterations.
- **Issue: Objects sticking together**: Check for overlapping initial positions or adjust contact parameters.

## Summary

This chapter introduced the fundamental concepts of physics simulation for humanoid robotics. We explored the key components of physics engines, the trade-offs between fidelity and performance, and practical considerations for configuring simulation environments. Physics simulation is essential for humanoid robot development, providing a safe and efficient way to test complex behaviors before real-world deployment.

## Further Reading

- Gazebo Documentation: Physics Engine Configuration
- NVIDIA Isaac Sim: Physics Simulation Guide
- Real-Time Physics Simulation Techniques

## References

For academic citations, use the references.bib file in the references/ directory.

## Exercises

1. Implement a custom physics plugin for Gazebo that adds specialized humanoid behaviors.
2. Compare the performance of different physics engines (ODE, Bullet, Simbody) for humanoid simulation.
3. Design a simulation environment that can be used to train humanoid balance controllers.

<!-- Optional: Add custom components for interactive elements -->